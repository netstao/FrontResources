yield中断其实会返回一个coroutine。捕获这个coroutine压到栈里。就可以了。

是这样子的。php的每一个函数都算是一段子程序。假设子程序里有yield关键字。
那么父程序在调用该子程序时，子程序就中断了，返回一个coroutine。对于PHP当前而言，
父程序依然是同步执行的。只是子程序被中断了。

嗯，我们的方案就是任务是一个队列。然后任务内协程调度会有一个栈。

假设一次请求会触发多次的函数调用。每一个函数体都是子程序，这些子程序如果有中断就会入栈。当前的这次请求视为一个任务，是在队列里。

嗯，我们还涉及了基于资源申请的协程能力。把IO，包括连接池等都视为资源，中断申请资源，分配以后继续执行。就把php调度这块当作一个小的操作系统了。